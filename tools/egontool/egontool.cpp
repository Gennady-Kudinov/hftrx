// egontool.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"



#if defined   (__GNUC__)        /* GNU Compiler */
	#include <stdint.h>
	#define ATTRPACKED __attribute__ ((packed))
#else
	#define ATTRPACKED
typedef unsigned int uint32_t;
typedef unsigned char uint8_t;

#endif /* __GNUC__ */



/* boot_file_head copied from mksunxiboot */
/* boot head definition from sun4i boot code */
typedef struct boot_file_head
{
	uint32_t  jump_instruction;   // +0000	one intruction jumping to real code
	uint8_t   magic[8];           // +0004	"eGON.BT0" or "eGON.BT1",  not C-style string.
	uint32_t  check_sum;          // +000C	generated by PC
	uint32_t  length;             // +0010	generated by PC
	uint32_t  pub_head_size;      // +0014	the size of boot_file_head_t
	uint8_t   pub_head_vsn[4];    // +0018	the version of boot_file_head_t
	uint8_t   file_head_vsn[4];   // +001C	the version of boot0_file_head_t or boot1_file_head_t
	uint8_t   Boot_vsn[4];        // +0020	Boot version
	uint8_t   eGON_vsn[4];        // +0024	eGON version
	uint8_t   platform[8];        // +0028	platform information
} ATTRPACKED boot_file_head_t;


static uint32_t alignup(uint32_t size, uint32_t page)
{
	return (size + page - 1) & ~ (page - 1);
}

static void fillpad(FILE * fp, long size)
{
	while (size --)
	{
		fputc(0x00, fp);
	}
}

static uint32_t cks(const uint8_t * p, unsigned size, uint32_t sum)
{
	while (size --)
		sum += * p ++;
	return sum;
}

int main(int argc, char* argv[])
{

	const char * const infilename = "../../build/allwinner_t113_s3/tc1_t113s3_boot.bin";
	const char * const outfilename = "../../build/allwinner_t113_s3/fsbl2.alw32";

	FILE * infile = fopen(infilename,"rb");
	FILE * outfile = fopen(outfilename,"wb");

	if (infile == NULL || outfile == NULL)
	{
		fprintf(stderr, "Can not open files...\n");
		return 1;
	}
	
	boot_file_head_t head;
	static const uint8_t magic [8] = { 'e', 'G', 'O', 'N', '.', 'B', 'T', '0' };	/* eGON.BT0 */
	static const uint8_t pub_head_vsn [8] = { '3', '0', '0', '0' };	/* 3000 */
	static const uint8_t platform [8] = {  '\0',  '\0',  '\0',  '\0', '4', '.', '0', '\0' };	/* 4.0 */
	static const uint8_t Boot_vsn [4]		= {  0x00, 0x00, 0x02, 0x00 };
	static const uint8_t file_head_vsn [4]	= {  0x00, 0x00, 0x02, 0x00 };
	const unsigned execoffset = 0x100;

	uint32_t check_sum;

	fseek(infile, 0, SEEK_END);
	const long binsize = ftell(infile);
	const long silesizealigned = alignup(binsize + execoffset, 16 * 1024);

	fprintf(stderr, "Okay open files... %ld %ld\n", binsize, silesizealigned);

	{
		/* checksum calculate */
		check_sum = 0;
		rewind(infile);
		long i;
		for (i = 0; i < binsize; ++ i)
		{
			int c = fgetc(infile);
			if (c == EOF)
				break;
			check_sum += c & 0xFF;
		}

	}


	/* Fill head */
	head.jump_instruction = 0xEA000000 + (execoffset - 8) / 4;	/// Jump to $ + 0x0100
	memcpy(& head.magic, magic, 8);
	head.check_sum = 0;//check_sum;
	head.length = silesizealigned;//binsize;
	head.pub_head_size = sizeof head;
	memcpy(& head.pub_head_vsn, pub_head_vsn, sizeof head.pub_head_vsn);
	memcpy(& head.file_head_vsn, file_head_vsn, sizeof head.file_head_vsn);
	memcpy(& head.Boot_vsn, Boot_vsn, sizeof head.Boot_vsn);
	memset(& head.eGON_vsn, 0x00, sizeof head.eGON_vsn);
	memcpy(& head.platform, platform, sizeof head.platform);

	check_sum += cks((const uint8_t *) & head, sizeof head, 0);
	head.check_sum = check_sum;


	fwrite(& head, 1, sizeof head, outfile);
	fillpad(outfile, execoffset - sizeof head);

	{
		/* copy file */
		rewind(infile);
		long i;
		for (i = 0; i < binsize; )
		{
			enum { CHUNKSIZE = 256 };
			uint8_t buff [CHUNKSIZE];
			unsigned chunk = CHUNKSIZE > (binsize - i) ? (binsize - i) : CHUNKSIZE;
			fread(buff, chunk, 1, infile);
			fwrite(buff, chunk, 1, outfile);
			i += chunk;
		}
	}

	fillpad(outfile, silesizealigned - binsize - execoffset);

	fprintf(stderr, "Okay processing... %ld %ld\n", binsize, silesizealigned);

	return 0;
}
