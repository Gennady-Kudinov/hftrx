%                                                                                                                                       
%THIS IS A WIZARD GENERATED FILE. DO NOT EDIT THIS FILE!                                                                                
%                                                                                                                                       
%---------------------------------------------------------------------------------------------------------                              
%This is a filter withfixed coefficients 
%This Model Only Support Single Channel Input Data. 
%Please input:                                                                                                                          
%data vector: 		stimulation(1:n)                                                                                                 
%                                                                                                                                       
%    This Model Only Support FIR_WIDTH to 51 Bits
%                                                                                                                                       
%FILTER PARAMETER                                                                                                                       
%Input Data Type:	Signed
%Input Data Width:	32
%Decimation Factor:   20
%MSB Truncated Bits: 1
%LSB Truncated bits:22
%FIR Width (Full Calculation Width Before Output Width Adjust) :   55
%-----------------------------------------------------------------------------------------------------------

	%MegaWizard Scaled Coefficient Values
	function  output = fir_20_2ch_mlab_mat (stimulation, output)
	coef_matrix=[0 0 0 0 0 0 0 0 0 -7 -11 -16 -23 -30 -37 -46 -54 -62 -70 -76 -81 -84 -84 -81 -74 -63 -48 -29 -5 24 57 94 134 176 220 265 308 350 388 420 446 464 471 467 451 421 376 317 242 153 49 -67 -195 -332 -476 -624 -773 -918 -1056 -1183 -1295 -1387 -1456 -1496 -1505 -1480 -1418 -1317 -1176 -994 -774 -515 -222 102 452 821 1204 1591 1975 2346 2694 3010 3284 3505 3666 3756 3770 3700 3543 3294 2952 2519 1998 1393 713 -34 -834 -1674 -2537 -3407 -4264 -5087 -5858 -6553 -7154 -7640 -7992 -8194 -8230 -8090 -7764 -7247 -6537 -5637 -4555 -3302 -1893 -351 1302 3035 4817 6612 8383 10088 11688 13141 14406 15443 16216 16691 16838 16632 16055 15094 13745 12011 9902 7438 4646 1564 -1764 -5285 -8939 -12659 -16373 -20003 -23468 -26685 -29569 -32038 -34008 -35401 -36145 -36171 -35421 -33845 -31403 -28067 -23821 -18663 -12603 -5667 2106 10665 19944 29863 40332 51250 62506 73980 85550 97083 108448 119512 130143 140211 149594 158175 165846 172510 178084 182495 185687 187619 188266 187619 185687 182495 178084 172510 165846 158175 149594 140211 130143 119512 108448 97083 85550 73980 62506 51250 40332 29863 19944 10665 2106 -5667 -12603 -18663 -23821 -28067 -31403 -33845 -35421 -36171 -36145 -35401 -34008 -32038 -29569 -26685 -23468 -20003 -16373 -12659 -8939 -5285 -1764 1564 4646 7438 9902 12011 13745 15094 16055 16632 16838 16691 16216 15443 14406 13141 11688 10088 8383 6612 4817 3035 1302 -351 -1893 -3302 -4555 -5637 -6537 -7247 -7764 -8090 -8230 -8194 -7992 -7640 -7154 -6553 -5858 -5087 -4264 -3407 -2537 -1674 -834 -34 713 1393 1998 2519 2952 3294 3543 3700 3770 3756 3666 3505 3284 3010 2694 2346 1975 1591 1204 821 452 102 -222 -515 -774 -994 -1176 -1317 -1418 -1480 -1505 -1496 -1456 -1387 -1295 -1183 -1056 -918 -773 -624 -476 -332 -195 -67 49 153 242 317 376 421 451 467 471 464 446 420 388 350 308 265 220 176 134 94 57 24 -5 -29 -48 -63 -74 -81 -84 -84 -81 -76 -70 -62 -54 -46 -37 -30 -23 -16 -11 -7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ];
	INTER_FACTOR  = 1;
	DECI_FACTOR  = 20;
	MSB_RM  = 1;
	MSB_TYPE  = 0;
	LSB_RM  = 22;
	LSB_TYPE  = 0;
	FIR_WIDTH  = 55;
	OUT_WIDTH  = FIR_WIDTH - MSB_RM - LSB_RM ;
	DATA_WIDTH = 32;
            
	data_type= 1;

        % check size of inputs.
        [DX,DY] = size(stimulation);
        [CX,CY] = size(coef_matrix);
        if (CX ~= DY * INTER_FACTOR)
	        fprintf('WARNING : coef_matrix size and input data size is not match\n');
        end
        
        %fill coef_matrix to length of data with the latest coef set
        if (CX < DY * INTER_FACTOR)
            for i= CX +1:DY * INTER_FACTOR
                coef_matrix(i,:) = coef_matrix(CX,:);
            end
        end

        %check if input is integer
       	int_sti=round(stimulation);
	    T = (int_sti ~= stimulation);
	    if (max(T)~=0)
	        fprintf('WARNING : Integer Input Expected: Rounding Fractional Input to Nearest Integer...\n');
	    end
	    
	    %Input overflow check
	    switch  data_type
	    case 1
	        %set max/min for signed
	        maxdat = 2^(DATA_WIDTH-1)-1;
	        mindat = -maxdat-1;
	    case 2
	        %set max/min for unsigned
	        maxdat = 2^DATA_WIDTH-1;
	        mindat = 0;
	    end

	    if(data_type == 2)
	    	if(abs(coef_matrix) == coef_matrix)
	    		FIR_WIDTH = FIR_WIDTH +1;
	    	end
	    end

	    %Saturating Input Value
	    a=find(int_sti>maxdat);
	    b=find(int_sti<mindat);
	    if (~isempty(a)|~isempty(b))
	 	    fprintf('WARNING : Input Amplitude Exceeds MAXIMUM/MINIMUM allowable values - saturating input values...\n');
	            lena = length (a);
	            lenb = length (b);
	            for i =1:lena
	        	    fprintf('%d > %d \n', int_sti(a(i)), maxdat);
			        int_sti(a(i)) = maxdat;
		        end
		    for i =1:lenb
			    fprintf('%d < %d \n', int_sti(b(i)), mindat);
			    int_sti(b(i)) = mindat;
		    end
	    end
        
	    % Add interpolation
   	    inter_sti = zeros(1, INTER_FACTOR * length(int_sti));
	    inter_sti(1:INTER_FACTOR:INTER_FACTOR * length(int_sti)) = int_sti;

        
        for i = 1 : DY *INTER_FACTOR
    	    coef_current = coef_matrix(i,:);
            output_temp(i) = simp_adaptive (inter_sti, coef_current, i);
        end
	% Truncate output
	len1 = length(output_temp);
	
	    switch  LSB_TYPE
	    case 0
	        %truncate
            out_dec = bi_trunc_lsb(output_temp,LSB_RM,FIR_WIDTH);
	    case 1
	        %round
            out_dec = bi_round(output_temp,LSB_RM, FIR_WIDTH);
	    end
        
 	    switch  MSB_TYPE
	    case 0
	        %truncate
            out_dec = bi_trunc_msb(out_dec,MSB_RM,FIR_WIDTH-LSB_RM);
	    case 1
	        %round
            out_dec = bi_satu(out_dec,MSB_RM, FIR_WIDTH-LSB_RM);
	    end
 	   
    	% choose decimation output in phase=DECI_FACTOR-1  
     	if(DECI_FACTOR == 1)
     		output = out_dec;
     	else
     		output = out_dec(DECI_FACTOR:DECI_FACTOR:len1);
 	    end 
 	      
  	function[output, outindex] = simp_adaptive (int_sti, coef_current, data_index, output)
	%Simulation is the whole input sequence
	%coef_current is the current coefficient set
	%data_index gives the last data to use
	%outputs are the sum of input and coef multiplication
	%outindex is the next data_index
   
	sti_current = zeros(length(coef_current),1);
	
	data_length = length(int_sti);
	
	%Check data index
	if (data_index > data_length)
		fprintf('ERROR: DATA INDEX IS LARGER THAN DATA LENGTH!!!\n');
		return;
	end
	for i = 1: length(coef_current)
	   if ((data_index -i+1)>0 & (data_index - i+1)<=data_length)
	      sti_current(i,1) = int_sti(data_index - i+1);
	   end
	end
	
	outindex= data_index+1;
	output = coef_current * sti_current;
	% end of function simp_adaptive

	function output = bi_round(data_in,LSB_RM,ORI_WIDTH, output)
	% LSB_RM is the bit to lose in LSB
	% ORI_WIDTH is the original data width
	data = round (data_in / 2^LSB_RM);
	output = bi_satu(data,0,ORI_WIDTH - LSB_RM);
	%end of function bi_trunc_lsb
	
	function output = bi_trunc_lsb(data_in,LSB_RM,ORI_WIDTH, output)
	% LSB_RM is the bit to lose in LSB
	% ORI_WIDTH is the original data width
	%2's complement system
	output = bitshift(2^ORI_WIDTH*(data_in<0) + data_in, -LSB_RM) - 2^(ORI_WIDTH-LSB_RM) *(data_in<0);
	% end of function bi_round
	
	function output = bi_trunc_msb(data_in,MSB_RM,ORI_WIDTH, output)
	% MSB_RM is the bit to lose in LSB
	% ORI_WIDTH is the original data width
	%2's complement system
	data = 2^ORI_WIDTH * (data_in < 0)+ data_in;
	erase_num = 2^(ORI_WIDTH - MSB_RM) - 1;
	data = bitand(data, erase_num);
	output = data - 2^(ORI_WIDTH - MSB_RM)*(bitget(data,ORI_WIDTH - MSB_RM));
	%end of bi_trunc_msb
	
	function output = bi_satu(data_in,MSB_RM,ORI_WIDTH, output)
	% MSB_RM is the bit to lose in LSB
	% ORI_WIDTH is the original data width
	%2's complement system
	maxdat = 2^(ORI_WIDTH - MSB_RM -1)-1;
	mindat = 2^(ORI_WIDTH - MSB_RM -1)*(-1);
	data_in(find(data_in > maxdat)) = maxdat;
	data_in(find(data_in < mindat)) = mindat;
	output = data_in;
	%end of bi_satu 
