%                                                                                                          
%THIS IS A WIZARD GENERATED FILE. DO NOT EDIT THIS FILE!                                                   
%                                                                                                          
%--------------------------------------------------------------------------------------------------------- 
%This Model Only Support Single Channel Input Data. 
%Please input:                                      
%data vector: 		stimulation(1:n)                
%FILTER PARAMETER  
%Input Data Width: 28
%Decimation Factor: 5
%MSB Truncated Bits:
%MSB Satuated Bits :
%LSB Truncated bits:
%LSB Rounded bits  :
%FIR Width (Full Calculation Width Before Output Width Adjust) :28 
%-----------------------------------------------------------------------------------------------------------
%MegaWizard Scaled Coefficient Values
 function  output = fir5_wfm_mlab(stimulation, output);
 coef_matrix=[0,0,0,0,0,0,0,0,5,4,0,0,-9,-13,-12,-5,6,18,25,23,11,-9,-30,-42,-40,-20,11,44,64,63,35,-11,-60,-92,-92,-56,8,77,125,129,84,0,-95,-163,-176,-121,-13,112,207,231,168,34,-128,-256,-297,-228,-64,140,310,375,302,106,-148,-367,-464,-391,-162,149,428,566,499,235,-140,-490,-681,-626,-327,119,553,808,774,442,-82,-612,-947,-945,-583,26,667,1098,1141,753,54,-713,-1259,-1363,-956,-161,746,1428,1611,1195,301,-763,-1603,-1887,-1474,-478,758,1781,2190,1795,699,-726,-1958,-2520,-2163,-968,659,2129,2877,2580,1293,-552,-2290,-3258,-3049,-1680,396,2433,3661,3573,2134,-184,-2553,-4082,-4153,-2664,-95,2640,4519,4792,3275,450,-2685,-4966,-5491,-3976,-891,2680,5417,6251,4775,1432,-2611,-5866,-7072,-5678,-2083,2466,6304,7956,6696,2861,-2230,-6723,-8902,-7839,-3781,1888,7113,9912,9118,4863,-1419,-7461,-10985,-10547,-6127,802,7756,12124,12144,7602,-10,-7980,-13332,-13929,-9320,-988,8118,14614,15933,11326,2235,-8146,-15978,-18192,-13674,-3782,8038,17440,20764,16443,5701,-7760,-19020,-23724,-19741,-8092,7265,20756,27190,23732,11101,-6488,-22703,-31340,-28660,-14951,5331,24959,36465,34931,20007,-3634,-27686,-43061,-43237,-26906,1117,31194,52059,54902,36884,2769,-36108,-65397,-72756,-52665,-9274,43938,87905,104182,81731,22033,-59369,-135785,-176253,-154576,-57880,107959,317892,532719,708393,807110,807110,708393,532719,317892,107959,-57880,-154576,-176253,-135785,-59369,22033,81731,104182,87905,43938,-9274,-52665,-72756,-65397,-36108,2769,36884,54902,52059,31194,1117,-26906,-43237,-43061,-27686,-3634,20007,34931,36465,24959,5331,-14951,-28660,-31340,-22703,-6488,11101,23732,27190,20756,7265,-8092,-19741,-23724,-19020,-7760,5701,16443,20764,17440,8038,-3782,-13674,-18192,-15978,-8146,2235,11326,15933,14614,8118,-988,-9320,-13929,-13332,-7980,-10,7602,12144,12124,7756,802,-6127,-10547,-10985,-7461,-1419,4863,9118,9912,7113,1888,-3781,-7839,-8902,-6723,-2230,2861,6696,7956,6304,2466,-2083,-5678,-7072,-5866,-2611,1432,4775,6251,5417,2680,-891,-3976,-5491,-4966,-2685,450,3275,4792,4519,2640,-95,-2664,-4153,-4082,-2553,-184,2134,3573,3661,2433,396,-1680,-3049,-3258,-2290,-552,1293,2580,2877,2129,659,-968,-2163,-2520,-1958,-726,699,1795,2190,1781,758,-478,-1474,-1887,-1603,-763,301,1195,1611,1428,746,-161,-956,-1363,-1259,-713,54,753,1141,1098,667,26,-583,-945,-947,-612,-82,442,774,808,553,119,-327,-626,-681,-490,-140,235,499,566,428,149,-162,-391,-464,-367,-148,106,302,375,310,140,-64,-228,-297,-256,-128,34,168,231,207,112,-13,-121,-176,-163,-95,0,84,129,125,77,8,-56,-92,-92,-60,-11,35,63,64,44,11,-20,-40,-42,-30,-9,11,23,25,18,6,-5,-12,-13,-9,0,0,4,5,0,0,0,0,0,0,0,0];
 INTER_FACTOR  = 1;         
 DECI_FACTOR  =  5;
 MSB_RM  = 2;
 MSB_TYPE  = 0;
 LSB_RM  = 22;
 LSB_TYPE  = 0;
 FIR_WIDTH  = 28 + MSB_RM + LSB_RM;
 OUT_WIDTH  = 28 ;  %28
  DATA_WIDTH = 28;
 data_type = 1;

 % check size of inputs. 
 [DX,DY] = size(stimulation);
 [CX,CY] = size(coef_matrix); 
 if (CX ~= DY * INTER_FACTOR) 
    fprintf('WARNING : coef_matrix size and input data size is not match\n'); 
 end 
   
 %fill coef_matrix to length of data with the latest coef set 
 if (CX < DY * INTER_FACTOR) 
   for i= CX +1:DY * INTER_FACTOR 
     coef_matrix(i,:) = coef_matrix(CX,:); 
   end 
 end
  
        %check if input is integer 
       	int_sti=round(stimulation); 
	    T = (int_sti ~= stimulation); 
	    if (max(T)~=0) 
	        fprintf('WARNING : Integer Input Expected: Rounding Fractional Input to Nearest Integer...\n'); 
	    end 
	     
	    %Input overflow check 
	    switch  data_type 
	    case 1 
	        %set max/min for signed 
	        maxdat = 2^(DATA_WIDTH-1)-1; 
	        mindat = -maxdat-1; 
	    case 2 
	        %set max/min for unsigned 
	        maxdat = 2^DATA_WIDTH-1; 
	        mindat = 0; 
	    end 

	    if(data_type == 2)
	    	if(abs(coef_matrix) == coef_matrix)
	    		FIR_WIDTH = FIR_WIDTH +1;
	    	end
	    end

	    %Saturating Input Value 
	    a=find(int_sti>maxdat); 
	    b=find(int_sti<mindat); 
	    if (~isempty(a)|~isempty(b)) 
	 	    fprintf('WARNING : Input Amplitude Exceeds MAXIMUM/MINIMUM allowable values - saturating input values...\n'); 
	            lena = length (a); 
	            lenb = length (b); 
	            for i =1:lena 
	        	    fprintf('%d > %d \n', int_sti(a(i)), maxdat); 
			        int_sti(a(i)) = maxdat; 
		        end 
		    for i =1:lenb 
			    fprintf('%d < %d \n', int_sti(b(i)), mindat); 
			    int_sti(b(i)) = mindat; 
		    end 
	    end 
         
	    % Add interpolation 
   	    inter_sti = zeros(1, INTER_FACTOR * length(int_sti)); 
	    inter_sti(1:INTER_FACTOR:INTER_FACTOR * length(int_sti)) = int_sti; 
 
         
        for i = 1 : DY *INTER_FACTOR 
    	    coef_current = coef_matrix(i,:); 
            output_temp(i) = simp_adaptive (inter_sti, coef_current, i); 
        end 
	% Truncate output 
	len1 = length(output_temp); 
	 
	    switch  LSB_TYPE 
	    case 0 
	        %truncate 
            out_dec = bi_trunc_lsb(output_temp,LSB_RM,FIR_WIDTH); 
	    case 1 
	        %round 
            out_dec = bi_round(output_temp,LSB_RM, FIR_WIDTH); 
	    end 
         
 	    switch  MSB_TYPE 
	    case 0 
	        %truncate 
            out_dec = bi_trunc_msb(out_dec,MSB_RM,FIR_WIDTH-LSB_RM); 
	    case 1 
	        %round 
            out_dec = bi_satu(out_dec,MSB_RM, FIR_WIDTH-LSB_RM); 
	    end 
 	    
    	% choose decimation output in phase=DECI_FACTOR-1  
     	if(DECI_FACTOR == 1) 
     		output = out_dec; 
     	else
     		output = out_dec;%(DECI_FACTOR:DECI_FACTOR:len1);
 	end  
 	       
  	function[output, outindex] = simp_adaptive (int_sti, coef_current, data_index, output) 
	%Simulation is the whole input sequence 
	%coef_current is the current coefficient set 
	%data_index gives the last data to use 
	%outputs are the sum of input and coef multiplication 
	%outindex is the next data_index 
    
	sti_current = zeros(length(coef_current),1); 
	 
	data_length = length(int_sti); 
	 
	%Check data index 
	if (data_index > data_length) 
		fprintf('ERROR: DATA INDEX IS LARGER THAN DATA LENGTH!!!\n'); 
		return; 
	end 
	for i = 1: length(coef_current) 
	   if ((data_index -i+1)>0 & (data_index - i+1)<=data_length) 
	      sti_current(i,1) = int_sti(data_index - i+1); 
	   end 
	end 
	 
	outindex= data_index+1; 
	output = coef_current * sti_current; 
	% end of function simp_adaptive 
 
	function output = bi_round(data_in,LSB_RM,ORI_WIDTH, output) 
	% LSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width
	data = round (data_in / 2^LSB_RM);       
	output = bi_satu(data,0,ORI_WIDTH - LSB_RM); 
	%end of function bi_trunc_lsb 
	 
	function output = bi_trunc_lsb(data_in,LSB_RM,ORI_WIDTH, output) 
	% LSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	output = bitshift(2^ORI_WIDTH*(data_in<0) + data_in, -LSB_RM) - 2^(ORI_WIDTH-LSB_RM) *(data_in<0); 
	% end of function bi_round 
	 
	function output = bi_trunc_msb(data_in,MSB_RM,ORI_WIDTH, output) 
	% MSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	data = 2^ORI_WIDTH * (data_in < 0)+ data_in; 
	erase_num = 2^(ORI_WIDTH - MSB_RM) - 1; 
	data = bitand(data, erase_num); 
	output = data - 2^(ORI_WIDTH - MSB_RM)*(bitget(data,ORI_WIDTH - MSB_RM)); 
	%end of bi_trunc_msb 
	 
	function output = bi_satu(data_in,MSB_RM,ORI_WIDTH, output) 
	% MSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	maxdat = 2^(ORI_WIDTH - MSB_RM - 1)-1; 
	mindat = 2^(ORI_WIDTH - MSB_RM - 1)*(-1); 
	data_in(find(data_in > maxdat)) = maxdat; 
	data_in(find(data_in < mindat)) = mindat; 
	output = data_in; 
	%end of bi_satu  
         
